# JavaScript

## Объекты

— один из базовых типов данных в JavaScript.

### Особенности объектов в JavaScript

1. Прототипное наследование: в JavaScript объекты могут наследовать свойства и методы от других объектов через прототипы. Каждый объект имеет скрытое свойство [[Prototype]], которое указывает на его прототип.
2. Динамическая природа: объекты в JavaScript динамически изменяемы. Вы можете добавлять, изменять и удалять свойства в любое время.
3. Ключи свойств: ключи свойств объектов могут быть строками или символами. Если вы используете числа или другие типы данных в качестве ключей, они будут автоматически преобразованы в строки.
4. Методы объекта: Встроенные методы объекта, такие как Object.keys(), Object.values(), Object.entries(), позволяют работать с объектами более эффективно.

### Создание объектов

Объект может быть создан с помощью фигурных скобок `{ … }` с необязательным списком свойств. Свойство – это пара `key: value` где ключ `key` – это строка, а значение может быть чем угодно:

```
let user = {};
```

Обычно используют вариант с фигурными скобками. Такое объявление называют `литералом объекта` или `литеральной нотацией`. При использовании литерального синтаксиса сразу можно поместить в объект несколько свойств в виде пар `key: value`:

```
let user = {
  name: "Daria",
  age: 32,
  isAwesome: true
};
```

Можно создавать объекты с помощью конструктора объектов `new Object`:

```
let user = new Object();
```

Затем для обращения к свойствам используется запись через точку:

```
person.name = "Daria";
person.age = 32;
person.isAwesome = true;

console.log(user.name);
console.log(user.age);
console.log(user.isAwesome);

```

Аналогично можно добавить свойство:

```
user.favColor = "purple";
```

Для удаления свойства можно использовать оператор `delete`:

```
delete user.age;
```

Имя свойства может состоять из нескольких слов. В этом случае оно записывается в кавычках:

```
let dog = {
  name: "Kesha",
  age: 3,
  "likes cats": true,
};
```

В этом случае для свойств, имена которых состоят из нескольких слов, доступ к значению через точку не работает и код ниже вызовет синтаксическую ошибку:

```
dog.likes cats = false;
```

Для таких случаев существует альтернативный способ доступа к свойствам через квадратные скобки. Такой способ сработает с любым именем свойства:

```
let dog = {};

dog["likes cats"] = true;
alert(dog["likes cats"]); // > true
delete dog["likes cats"];
```

Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения. Например, имя свойства может храниться в переменной:

```
let key = "likes cats";

// то же самое, что и dog["likes cats"] = true;
dog[key] = true;

```

Запись через точку такого не позволяет:

```
let dog = {
  name: "Kesha",
  age: 3
};

let key = "name";
alert(dog.key); // > undefined
```

Можно обратить внимание, что последнее свойство может заканчиваться запятой, она называется `висячая запятая` (trailing commas).

Объект, объявленный через `const`, может быть изменён:

```
const user = {
  name: "Bob"
};

user.name = "Alice";

alert(user.name);
```

Объявление через `const` защищает от изменений только саму переменную `user`, а не её содержимое. Определение через `const` выдаст ошибку только если присвоить переменной другое значение:

```
user = {
    name: "Alice"
}
```

### Проверка существования свойств

При обращении к свойству, которого нет, возвращается `undefined`. Это позволяет просто проверить существование свойства:

```
let dog = {
    name: "Kesha",
    "likes cats: true,
};

alert(dog.age === undefined); // > true означает что свойства нет
```

Также существует специальный оператор `in` для проверки существования свойства в объекте:

```
let user = {
    name: "Daria",
    age: 32
};

console.log("age" in user ); // true, user.age существует
console.log("blabla" in user); // false, user.blabla не существует
```

В большинстве случаев прекрасно сработает сравнение с `undefined`, но есть особый случай, когда оно не подходит и нужно использовать `in` - когда свойство существует, но содержит значение `undefined`:

```
let obj = {
  test: undefined
};

console.log(obj.test); //  выведет undefined, значит свойство не существует???
console.log("test" in obj); // true, свойство существует!
```

### Перебор свойств объектов

Для перебора всех свойств объекта используется цикл `for..in`:

```
let user = {
  name: "Daria",
  age: 32,
  isAwesome: true
};

for (let key in user) {
  alert(key);  // name, age, isAwesome
  alert(user[key]); // Daria, 32, true
}
```

### Методы объекта

Методы — это функции, которые являются свойствами объекта. Можно добавлять методы к объектам:

```
const person = {
  name: "Daria",
  age: 32,
  greet: function() {
    console.log(`Hello, my name is ${this.name}`);
  }
};

person.greet(); // Выведет: Hello, my name is Daria
```

### Сравнение объектов

Объекты — ссылочный тип данных. Примитивные значения (например, числа или строки) хранятся в переменной как есть, а объекты, массивы и функции — по ссылке на место в памяти. Связано это с тем, что с объектами и другими сложными данными мы не знаем, какое количество памяти для них понадобится.

При сравнении двух объектов JavaScript сравнивает не значения свойств этих объектов, а адреса в памяти, по которым эти объекты хранятся. Поэтому любое сравнение двух объектов будет возвращать `false`, даже если они выглядят одинаково:

```
const book = { title: 'Дюна' };
const anotherBook = { title: 'Дюна' };

console.log(book === anotherBook); // Выведет: false
```

Сравнение будет возвращать `true`, только если мы сравниваем переменные, указывающие на один и тот же объект:

```
const book = { title: 'Дюна' };
const anotherBook = book;

console.log(book === anotherBook); // Выведет: true
```

Пример ниже показывает как работает хранение объектов по ссылке. В начале переменные `mouse` и `cat` указывают на собственные объекты.
В строке `mouse = cat` присваиваем переменной `mouse` ссылку на объект `cat`. Можно рассматривать это как "связывание" переменных. Теперь обе переменные указывают на один и тот же объект `{ name: 'Tom', isHunter: true}`. Теперь `mouse.name` и `cat.name` будут менять значения свойства одного и того же объекта.
Последнее изменение в этом объекте происходит присваиванием значения `undefined` ключу `isHunter`.
Выводя в консоль значение ключа `isHunter`, получим последнее его обновление — `undefined`.

```
let cat = {
  name: 'Tom',
  isHunter: true
}

let mouse = {
  name: 'Jerry',
  isHunter: false
}

mouse = cat;
cat.isHunter = false;
mouse.isHunter = undefined;

console.log(mouse.isHunter); // Выведет: undefined
```

Если нужно безопасно модифицировать объект, то для начала придётся его скопировать. Скопировать объект можно двумя способами: через `Object.assign()` или используя спред-синтаксис `...`. Таким образом будет создана совсем новая сущность, которая будет содержать ровно те же значения:

```
const user = {
  name: 'Daria',
  age: 32,
  isAwesome: true,
}

// Чтобы скопировать через `Object.assign()` нужно передать пустой объект
const userCopy = Object.assign({}, user);

const anotherCopy = {
  ...user,
}
```

Любые изменения в новом объекте уже не затронут предыдущий:

```
anotherCopy.age = 29
anotherCopy.isAwesome = false

console.log(anotherCopy)
// {name: 'Daria', age: 29, isAwesome: false }

console.log(user)
// {name: 'Daria', age: 32 , isAwesome: true }
```

Здесь стоит внести важную оговорку о вложенных объектах. При копировании объекта указанным способом копируются только поля верхней вложенности (сработает поверхностное копирование). Любые вложенные объекты копируются по ссылке. Их изменение затронет и первоисточник:

```
const original = {
  b: {
    c: 1,
  },
}

const copy = { ...original };
copy.b.c = 2;

// Тоже изменился!
console.log(original); // Выведет: { b: { c: 2 }}
```

## Источники

1. [Объекты | Дока](https://doka.guide/js/object/)
2. [ Хранение по ссылке и по значению | Дока](https://doka.guide/js/ref-type-vs-value-type/)
