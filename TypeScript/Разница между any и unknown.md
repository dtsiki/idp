# TypeScript

## Разница между `any` и `unknown`

Литеральные типы существуют для четырех типов данных:

- `boolean`
- `string`
- `number`
- `BigInt`

В итоге любой литеральный тип можно присвоить переменной соответствующего типа:

```ts
let num: number = 1;
const two: 2 = 2;
const notTrue: false = false;

num = two;
num = notTrue; // Type 'boolean' is not assignable to type 'number'.
```

Здесь 2 используется как литеральный тип, который представляет собой множество из одного элемента — двойки.

Анализатор успешно пропустил присваивание литерального типа числа к number, но литеральный `boolean` тип мы уже не смогли присвоить. Чтобы решить эту проблему, можно использовать объединение типов `number | boolean`. Но если мы не уверены, что может быть присвоено, нам пришлось бы делать объединение с потенциально огромным числом типов.

В этом случае нам на помощь приходит тип `unknown`.

# unknown

Тип `unknown` — это надмножество всех доступных типов. Он позволяет присвоить переменной значение произвольного типа:

```ts
let unknownValue: unknown = 1;
const two: 2 = 2;
const notTrue: false = false;

unknownValue = two;
unknownValue = notTrue; // OK
```

Может показаться, что тип `unknown` работает так же, как `any`, однако между ними есть различие. Тип `any` по сути отключает проверку типов и позволяет выполнять любые операции со значением, например, обращаться к свойствам переменной. Тип `unknown` запрещает это и требует предварительной проверки типа переменной, либо приведения к нужному типу.

## any

Тип `any` является уникальным для TypeScript, в JavaScript подобного типа не существует.

Все типы в TypeScript являются подтипами `any`. Это означает что он совместим в обе стороны с любым другим типом и с точки зрения системы типов является высшим типом (top type).

```ts
let something: any = 0;
something = "Yay";
something = true;
```

Поскольку значение, принадлежащее к типу `any`, совместимо с любыми другими значениями, это может привести к непредсказуемым последствиям. Поэтому указывать данный тип в аннотации настоятельно рекомендуется только в самых крайних случаях.

Поскольку тип `any` позволяет работать со значением динамически, это не вызывает ошибок при обращении к неописанным в типе членам, что сводит пользу от типизации к нулю.

Примером этого может служить сервис, который работает с сервером посредством API. Полученные и сериализованные данные могут храниться как тип `any`, прежде чем они будут преобразованы к конкретному типу:

```ts
let data: any = JSON.parse('{"id": "abc"}');
let id = data.id; // Не вызовет никаких ошибок
```

Если при объявлении переменных и полей не было присвоено значение, компилятором будет выведен тип данных `any`:

```ts
var something; // something: any
let anotherSomething; // anotherSomething: any

class SomethingClass {
  name; // name: any
}
```

То же правило касается и параметров функций:

```ts
function doSomething(something) {
  // something: any
}
```

Кроме того, если функция возвращает значение, принадлежащее к типу, который компилятор не в состоянии вывести, то возвращаемый этой функцией тип данных будет также выведен как тип `any`.

```ts
function sum(a, b) {
  // function sum(a: any, b: any): any
  return a + b;
}
```

They are different in semantics.

- unknown is the parent type of all other types. it's a regular type in the type system.
- any means "disable the type check". it's a compiler directive.

## Источники

1. ['unknown' vs. 'any'](https://stackoverflow.com/questions/51439843/unknown-vs-any)
2. [Иерархия типов](https://ru.hexlet.io/courses/typescript-basics/lessons/type-hierarcy/theory_unit)
3. [Базовый Тип Any](https://scriptdev.ru/guide/012/#any_1)
